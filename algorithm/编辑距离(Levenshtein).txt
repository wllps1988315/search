编辑距离定义:
编辑距离,又称Levenshtein距离,是指两个字符串之间,由一个转换成另一个所需的最少编辑操作次数.
许可的编辑操作包括:将一个字符替换成另一个字符,插入一个字符,删除一个字符.
例如,将eeba转变成abac:

1.eba(删除第一个e)
2.aba(将剩下的e替换成a)
3.abac(在末尾插入c)

所以eeba和abac的编辑距离是3
俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念.

算法:
算法就是简单的线性动态规划(最长上升子序列就属于线性动态规划).
设我们要将s1变成s2
定义状态距离edit[len1][len2],len1和len2分别是要比较的字符串s1和字符串s2的长度+1(+1是考虑到动态规划中,
一个串为空的情况)
然后,定义edit[i][j]是s1中前i个字符组成的串,和s2中前j个字符组成的串的编辑距离
具体思想是,对于每个i,j,从0开始依次递增,对于每一次j++,由于前j-1个字符跟i的编辑距离已经求出,所以只用考虑新加进来的第j个字符即可

插入操作:在s1的前i个字符后插入一个字符ch,使得ch灯具新加入的s2[j].于是插入字符的编辑距离就是edit[i][j-1] + 1

删除操作:删除s1[i],以期望s1[j-1]能与s2[j]匹配(如果s1[i-1]前边的几个字符能与s2[j]前边的几个字符有较好的匹配,那么这么做就能得到
更好的结果).另外,对于s1[i-1]之前的字符跟s2[j]匹配的情况,edit[i-1][j]中已经考虑过了.于是删除字符ch的编辑距离就是edit[i-1][j] + 1

替换操作:期望s1[i]与s2[j]匹配,或者将s1[i]替换成s2[j]后匹配.于是替换操作的编辑距离就是edit[i-1][j-1]+f(i,j).
其中,当s1[i]==s2[j]时,f(i,j)为0;反之为1.
于是动态规划公式如下:
if i==0 且 j==0, edit(i,j) = 0
if i==0 且 j>0, edit(i,j) = j
if i>0 且 j==0, eidt(i,j) = i
if 0<i<=1 且 0 <j <= 1, edit(i,j) == min{edit(i-1,j)+1,eidt(i,j-1) + 1,edit(i-1,j-1) + f(i,j)},当第一个字符串饿第i个字符
不等于第二个字符串的第j个字符时,f(i,j)=1;否则,f(i,j) = 0

源于:http://blog.csdn.net/luo123n/article/details/9999481